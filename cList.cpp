#include "cList.h"
#include <iostream>
using namespace std;

//ДОБАВЛЕНИЕ ЭЛЕМЕНТА В СПИСОК
void cList::push(int data)
{
    cList *ls = new cList;
    ls->data = data;
    ls->Next = NULL;
    counter++;
    if (!Head)
    {
        ls->Prev = NULL;
        Head = ls;
        Tail = Head;
    } else
    {
        ls->Prev = Tail;       //Указываем, что предыдущим элементом списка относительно добавленного, будет последний элемент существующего списка
        Tail->Next = ls;       //Следующий за последним существующим это непосредственно сейчас добавляемый элемент списка
        Tail = ls;             //После того как указали что есть настоящий и что предыдущий, объявляем, что последний существующий это только что добавленный элемент
    }
}

//ПОКАЗЫВАЕТ СПИСОК НА ЭКРАНЕ
void cList::Show()
{
    cList *t = Head;
    while (t)
    {
        cout << t->data << " ";
        t = t->Next;
    }
    cout << "\n\n";
}


//фУНКЦИЯ УДАЛЕНИЯ КОНКРЕТНОГО ЭЛЕМЕНТА ДВУСВЯЗНОГО СПИСКА
void cList::popN(int data)
{
    //Если удаляем первый элемент, то могут быть такие варианты
    //В списке есть только первый, в списке есть несколько элементов
    //Поэтому разбиваем логику выполнения
    if ((data == 1) and (Head->Next))                   //Если удаляем первый, но есть и другие, то
    {
        cList *ls = Head;	                            //Указываем, что нам нужно начало списка
        Head = Head->Next;	                            //Сдвигаем начало на следующий за началом элемент
        Head->Prev = NULL;	                            //Делаем так, чтоб предыдущий началу элемент был пустым
        delete ls;		                                //Удаляем удаляемое начало
        counter--;		                                //Обязательно уменьшаем счетчик
        return;		                                    //И выходим из функции
    } else if ((data == 1) and (Head == Tail))          //Если удаляем первый, но в списке только 1 элемент
    {
        Head->Next = NULL;	                            //обнуляем все что нужно
        Head = NULL;
        delete Head;		                            //Удаляем указатель на начало
        counter = 0;		                            //Обязательно обозначаем, что в списке ноль элементов
        return;			                                //и выходим из функции
    }

    //Также может быть, что удаляемый элемент является последним элементом списка
    if (data==counter)
    {
        cList *ls = Tail;	                            //Указываем, что нам нужен хвост
        Tail = Tail->Prev;	                            //Отодвигаем хвост немного назад
        Tail->Next = NULL;	                            //Обозначаем, что впереди за хвостом пусто
        delete ls;	                                    //Очищаем память от бывшего хвоста
        counter--;		                                //Обязательно уменьшаем счетчик элементов
        return;		                                    //И выходим из функции
    }

    //Если же удаляемый элемент лежит где-то в середине списка, то тогда его можно удалить

    cList *ls = Head, *ls2;                 //ls-Удаляемый элемент, ls2 , чтобы не потерять данные

    for (int i = 0; i < data-1; i++)
        ls = ls->Next;                      //Идем к адресу удаляемого элемента

    ls2 = ls;	                            //Временно запоминаем адрес удаляемого элемента
    ls2->Prev->Next = ls->Next;	            //Записываем данные, что следующий за перед сейчас удаляемым элементом - это следующий от удаляемого
    ls2->Next->Prev = ls->Prev;             //а предыдущий для следующего - это предыдущий для удаляемого
    delete ls;                              //теперь можно освободить память, удалив адрес на начало удаляемого элемента
    counter--;                              //Обязательно уменьшаем число элементов в списке.
}


//ДЕСТРУКТОР ДЛЯ КОРРЕКТНОГО ВЫСВОБОЖДЕНИЯ ПАМЯТИ
cList::~cList()
{
    while (Head)
    {
        Tail=Head->Next;
        delete Head;
        Head=Tail;
    }
}
